---
categories:
  - 读书
  - 计算机系统概论
tags:
  - 读书
  - 计算机系统概论
mathjax: true
title: 【计算机系统概论Yale.patt】2.数据的表示与计算
abbrlink: 465310364
date: 2023-05-27 21:41:50
---

[TOC]

<!--more-->

# 2.数据的表示与计算

## 2.1 bit

### 2.1.1 信号的编码表示

一个由自然语言描述的问题，最终必须转换为计算机内部的电路工作——电子的运动，才能得以解决

在计算机内部，电子器件控制着电子的运动：监测电压大小并做出不同的响应控制。

检测电路中的电压大小会导致电路比较复杂，但只检测电路中是否有电压则很简单，会大大减低电路复杂性

从符号层面，采用 `1` 表示两点间存在电压；`0` 表示两点之间不存在电压，即二进制表示方法

- `0` 并不变时电路中绝对不存在电压，仅代表当前 `0` 所代表的电压比 `1` 代表的电压更接近电压值 `0` 
- 机内将 $2.9V$ 表示为1

计算机需要定义足够大的数值范围才能工作。由于一条电路只有两个状态（1——有电压，0——无电压），为表示更多的数值状态，可以将多条线路合并使用。

通常 $k$ bit宽度（k条线路）可以表示 $2^k$ 个不同的电路状态，每个状态为k个0和1的bit序列组合，称该序列为编码，每个编码对应一个特定的值与电路状态

### 2.1.2 计算机采用二进制的原因

- 可行性：二进制只有01两个状态，能标识01两种状态的电子器件很多。
- 运算简易性：二进制运算法则少，运算简单，简化硬件结构
- 有逻辑代数的理论基础：二进制0和1正好和逻辑代数的真假对应

> 其实除了可行性，其他性质都是因为采用了二进制才进而凸显的，不过为了应试，就附上吧

### 2.1.3 数据类型

数据类型定义了：

- 数值的表示方式（编码方式）
- 数值相关的操作方法

>每个计算机指令集（ISA）都定义了一组数据类型及其相应的操作指令
>
>- 数据类型的设计取决于ISA的设计要求

#### 无符号整数

用于表示：执行次数，内存单元地址等没有大小意义，仅作为标记或计数的场景

k个bit可以表示 $2^k$ 个无符号整数（从 $0$ 到 $2^{k}-1$）

#### 有符号整数

在实际的算术运算中，存在着大量的负数。可以将 $2^k$ 个k-bit数分为两部分，一部分表示正数，另一部分表示负数

规定 `000...000` 表示数值0

计算机中，表示数值的正负需要占用一bit作为符号位，有四种数值表示方法——编码方式（二进制的不同解释方式）

##### 原码

n+1位定点(小数点)整数范围 $-2^n-1\sim2^n-1$

n+1位定点小数范围 $-1+2^{-n}\sim 1-2^{-n}$

- 字长足够，则可表示任意整数
- 不能表示任意小数，只能是2的整数次幂
- 真值0不唯一，可表示数少1

##### 反码

![](2-第二章/image-20220506235419763.png)

##### 补码

$n+1$ 位二进制数可表示

- 定点整数 $-2^n\sim 2^n-1$

- 定点小数 $-1\sim 1-2^{-n}$

![image-20220510212054719](2-第二章/image-20220510212054719.png)

**原码变为补码**：从右到左，找到第一个1，其左边取反，其右边不变
$$
\begin{aligned}
&原码：0111 0100\\
&补码：1000 1100
\end{aligned}
$$

- 正数补码等于原码（什么编码都不变）
- 负数补码等于原码取反加一

![](2-第二章/image-20220510220657763.png)

**补码运算应满足的性质**

- 绝对值相同但符号相反的两个数之和应为0

- 相邻两个码字之间相差为00...001

  REPRESENTATION(value+1)=REPRESENTATION(value)+REPRESENTATION(1)

在计算机中，完成加法运算的是ALU，他是一种计算**机制** ，只会对二进制数进行加法操作，而不考虑其他因素（正数、负数或加法累计效果），即 **策略** 由上层指定

具体运算策略见组成原理对这部分的解释

##### 编码方式与范围

| n bit二进制编码方式 | 最小值编码   | 最小值      | 最大值编码   | 最大值      | 数值个数 |
| ------------------- | ------------ | ----------- | ------------ | ----------- | -------- |
| 无符号定点整数      | 0000...000   | 0           | 1111...111   | $2^{n+1}-1$ | $2^{n}$  |
| 无符号定点小数      | 0.00...000   | 0           | 0.11...111   | $1-2^{-n}$  | $2^{n}$  |
| 原码定点整数        | $1111...111$ | $-2^n+1$    | 0111...111   | $2^n-1$     | $2^n-1$  |
| 原码定点小数        | $1.00...000$ | $-1-2^{-n}$ | $0.11...111$ | $1-2^{-n}$  | $2^n-1$  |
| 补码定点整数        | $100...000$  | $-2^n$      | $011...1111$ | $2^n-1$     | $2^n$    |
| 补码定点小数        | $1.00...000$ | $-1$        | $0.11...111$ | $1-2^{-n}$  | $2^n$    |

##### 移码

> 真值加常数

- 唯一用途就是二进制编码越大，所表示的数值越大

$$
\begin{aligned}
&[x]_移=2^n+x（-2^n\le x \le 2^n，机器字长为n+1）\\
&x_1=+10101，x_2=-10101，字长8位，则其移码表示为：\\
&[x_1]_移=2^7+10101=1,0010101,[x_2]_移=2^7+(-10101)=0,1101011
\end{aligned}
$$

![](2-第二章/image-20220512203609603.png)

**n位二进制能表示 $2^n$ 个数字**

**移码一般是加10...01** ，即编码表示的无符号整数减去 $2^{n}-1$ 

##### 4-bit的不同编码方式

| 二进制 | 原码 | 反码 | 补码 | 移码+1001 |
| ------ | ---- | ---- | ---- | --------- |
| 0000   | 0    | 0    | 0    | -7        |
| 0001   | 1    | 1    | 1    | -6        |
| 0010   | 2    | 2    | 2    | -5        |
| 0011   | 3    | 3    | 3    | -4        |
| 0100   | 4    | 4    | 4    | -3        |
| 0101   | 5    | 5    | 5    | -2        |
| 0110   | 6    | 6    | 6    | -1        |
| 0111   | 7    | 7    | 7    | 0         |
| 1000   | -0   | -7   | -8   | 1         |
| 1001   | -1   | -6   | -7   | 2         |
| 1010   | -2   | -5   | -6   | 3         |
| 1011   | -3   | -4   | -5   | 4         |
| 1100   | -4   | -3   | -4   | 5         |
| 1101   | -5   | -2   | -3   | 6         |
| 1110   | -6   | -1   | -2   | 7         |
| 1111   | -7   | -0   | -1   | 8         |

### 2.1.4 IEEE754浮点数

> 浮点数可以表示很大的数值，也可以表示很小的数值，只是牺牲一些数值精度而已

符号位：1bit，表示数值的正负

数值范围：8bit，代表范围（指数，exponent）

数值精度：23bit，代表精度（位数部分，fraction）

![image-20230531160925607](2-第二章/image-20230531160925607.png)

#### 尾数

> 准确的，不存在任何误差的bit的位数为**精度**

在IEEE中，尾数是正则化的，即小数点左边有且仅有一个非零数

在二进制下， 正则化的尾数为 `1.xxxxx`

即用23bit尾数就可表示24位精度

#### 指数

8-bit的二进制数可表示256个无符号整数，在IEEE中，指数值范围为 $1\sim 254$ ，剩余的两个指数 `00000000`  和 `11111111` 有特殊含义

指数部分为移码

- 实际的指数值等于该无符号整数减127之后的结果——相当于加 `1000 0001`

| 二进制    | 指数值    |
| --------- | --------- |
| 0000 0000 | 特殊含义  |
| 0000 0001 | -126      |
| .... .... | .... .... |
| 0111 1111 | 0         |
| 1000 0000 | 1         |
| .... .... | .... .... |
| 1111 1110 | 127       |
| 1111 1111 | 特殊含义  |

##### 0000 0000 含义

表示指数值为-126，但尾数不是正规化的

- 尾数是 `0...0` ，则为0
- 尾数非0，则该浮点数的值为 $(-1)^s\times 0.尾数\times 2^{-126}$ 

##### 1111 1111含义

- 尾数全0，无穷大
- 尾数不全为0，非数值

#### 例

用IEEE浮点数标准表示 $-6\frac{5}{8}$

符号位为1

$\frac{5}{8}=.101$，$6=110$ ——$110.101$ 正则化后为 $1.10101\times 2^{2}$

指数部分 `2+127=0000 0010+0111 1111=1000 0001` 

故 IEEE的浮点数表示为：`1 1000 0001 101 0100 0000 0000 0000 0000`

---

IEEE浮点数0 0111 1011 00000000000000000000000表示什么数

符号位s=0，表示整数

指数部分：`0111 1011` -127 为 $123-127=-4$ 

尾数部分：`1.0xxx0`

所以该二进制数表示 $+1.0\times 2^{-4}$ 

## 2.2 进制转换

### 2.2.1 二转十

$a_7a_6a_5a_4a_3a_2a_1a_0$

1. 8bit补码数据，最高位 $a_7$ 为符号位

   - 为0，则直接进行第二步转换 $a'_{6}a'_{5}a'_{4}a'_{3}a'_{2}a'_{1}a'_{0}=a_6a_5a_4a_3a_2a_1a_0$

   - 为1，需要转换为绝对值相等的正数——取反+1

     $a'_{6}a'_{5}a'_{4}a'_{3}a'_{2}a'_{1}a'_{0}=\overline{a_6a_5a_4a_3a_2a_1a_0}+1$ 

2. $x=a^{'}_6\times 2^6+a_5 \times 2^5+a_4\times 2^4+a_3 \times 2^3+a_2\times 2^2+a_1 \times 2^1+a_0\times 1$

3. 若为负数，加上负号即可

### 2.2.2 十转二

1. 将十进制数N展开为2次幂的求和

   $N=a_6\times 2^6+a_5\times 2^5+a_4\times 2^4+a_3\times 2^3+a_2\times 2^2+a_1\times 2^1+a_0\times 2^0$ 

   反复执行一下操作，直至N变为0

   - 如果N为奇数，则左边最低位 $a_i$ 为1。如果N为偶数，则左边最低位 $a_i$ 为0
   - 即将等式两端同时减1（奇数）或0（偶数），消除最低位后，将等式两端同时除以2

   每执行一次，可以求得一个 $a_i$ 的值

2.  如果N值为正，则 $a_7$ 取值为0

3. 如果N值为负，则最高位补0，然后求该编码的补码，完成

和手算的取余，然后逆序一样

![image-20230530172849492](2-第二章/image-20230530172849492.png)

### 2.2.3 二转十六

适合计算机计算且方便人阅读

一个16bit的二进制数 $a_{15}a_{14}a_{13}a_{12}a_{11}a_{10}a_{9}a_{8}a_{7}a_{6}a_{5}a_{4}a_{3}a_{2}a_{1}a_{0}$

其相应的无符号整数表示为 
$$
\begin{aligned}
&2^{15}\times a_{15}+2^{14}\times a_{14}+2^{13}\times a_{13}+2^{12}\times a_{12}+2^{11}\times a_{11}+2^{10}\times a_{10}+2^{9}\times a_{9}+2^{8}\times a_{8}+\\
&2^{7}\times a_{7}+2^{6}\times a_{6}+2^{5}\times a_{5}+2^{4}\times a_{4}+2^{3}\times a_{3}+2^{2}\times a_{2}+2^{1}\times a_{1}+2^{0}\times a_{0}
\end{aligned}
$$
从低位到高位，每四位为一组
$$
\begin{aligned}
2^{12}\times [2^3\times a_{15}+2^{2}\times a_{14}+2^1\times a_{13}+2^{0}\times a_{12}]\\
+2^{8}\times [2^3\times a_{11}+2^{2}\times a_{10}+2^1\times a_{9}+2^{0}\times a_{8}]\\
+2^{4}\times [2^3\times a_{7}+2^{2}\times a_{6}+2^1\times a_{5}+2^{0}\times a_{4}]\\
+2^{0}\times [2^3\times a_{3}+2^{2}\times a_{2}+2^1\times a_{1}+2^{0}\times a_{0}]\\
=16^3\times h_3+16^2\times h_2+16^1\times h_1+16^0\times h_0
\end{aligned}
$$
由于 $h_i$ 共有16种取指($0\sim 15$) ，用符号 $0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F$ 作为 $h_i$ 的值

- 0表示 $0000$
- 1表示 $0001$
- A表示 $1010$
- F表示 $1111$

十六进制的主要好处在于方便记忆和使用。避免了因二进制数字串过长引起的誊写错误

## 2.3 bit运算

### 2.3.1 加减法

二进制加法与十进制加法相同，从右向左将两数按列对齐并依次相加；如果前列的加法产生进位，则该进位bit参加左边列的加法操作

---

11+3
$$
\begin{aligned}
&01011\\
&00011\\
&--\\
&01110\\
\end{aligned}
$$

---

**减法理解为加负数**，$A-B=A+(-B)$

---

14-9(01001)
$$
\begin{aligned}
&01110\\
&10111\\
&--\\
&00101
\end{aligned}
$$

---

加本数相当于乘2，在位运算相当于左移1为

$x+x\iff x<<1$

#### 符号扩展

将两个长度不等的二进制相加，需要进行对齐操作——符号扩展

补码运算 (Sign Extension，简称SEXT)

- 正数前0扩展不改变原值
- 负数前1扩展不改变原值

![image-20230531094656091](2-第二章/image-20230531094656091.png)

![image-20230531094712681](2-第二章/image-20230531094712681.png)

#### 溢出

运算结果超出编码的最大值或最小值的情况

无符号整数溢出情况：最高位发生进位

有符号整数溢出情况：

- 正数与正数相加
- 负数与负数相加

### 2.3.2 逻辑运算

对两个长度为 m-bit 的二进制数做逻辑运算，将两个操作数按位对齐，然后对其中每一对bit进行运算，称为按位逻辑操作

- 只影响本位，不是算术运算，所以没有进位

**作用：**

- 判断某位的取值(0/1)
  - 当判断最后一位是0或是1时，可判断二进制表示数值的奇偶

- 取出二进制数的某一位
- 某位置为0/1
- 位取反——非运算
- 用于比较两数是否相等——异或

#### 逻辑操作的描述方式——真值表

对于n个操作数的逻辑操作，构造

- 行数——$2^n$
  - n个操作数的可能组合数为 $2^n$ 种
- 列数——$n+1$
  - 前n列表示n个源操作数
  - 最后一列表示该组合方式下逻辑运算的结果

的真值表

#### 按位与

全1得1，有0得0

```cpp
a=0011101001101001
b=0101100100100001
a&b=
  0001100000100001
```

与运算作用：

**位置0** ：与0

- 应用：计算n二进制的个数—— 每步使最低位的1变0 `n=n&(n-1);count++;` 直至 `n==0` 

  减法，向最低可进位借1，改为变为0，与减1之后的数相与，可将最低可借位和低位置0，高位不变

**判断某位取值** ：与1 

**取特定位** ：屏蔽字位：两部分组成

- 关心的位——目标位取1
- 忽略的位——其余为0

作用是将关心的位提出来——取某位

---

如取出8-bit数据A的低2位，其屏蔽字为 `0000 0011` ，无论A取何值，与屏蔽字与的结果必然是 `00000000` 、`00000001` 、`00000010` 、`00000011` 中的一个

---

#### 或运算

全0得0，有1得1

```cpp
a=0011101001101001
b=0101100100100001
a|b=
  0111101101101001
```

与运算作用：

**位置1** ：或1

**判断某位取值** ：或1

#### 非运算

按位取反

```cpp
a=0011101001101001
~a=
  1100010110010110
```

#### 异或运算

按位异或

异或真值表

| A    | B    | XOR  |
| ---- | ---- | ---- |
| 0    | 0    | 0    |
| 1    | 0    | 1    |
| 0    | 1    | 1    |
| 1    | 1    | 0    |

- 两个输入值不同，则输出为1
- 两个输入值相同，则输出为0

```cpp
a=0011101001101001
b=0101100100100001
a^b=
  0110001101001000
```

用于判断两个二进制数是否相同

- 若两个数相等，则异或之后为0

#### 应用——位矢量

在复杂系统中，包含了很多独立单元，每个单元或忙或空闲。

假设存在n个单元，可以用一个 n-bit 的二进制数代表这n个单元。

- 当某个单元忙碌时，将相应的bit置1—— `|0...010...0` 
- 当某个单元空闲时，将相应的bit置0——`&1...101...1`

## 2.4 ASCII

> 用于在计算机处理单元和IO设备之间传递字符的8-bit编码标准。

键盘上每个键位一般不止对应一个ASCII码

- 通过功能键 `shift` 切换

每次按键都会产生唯一的ASCII码

