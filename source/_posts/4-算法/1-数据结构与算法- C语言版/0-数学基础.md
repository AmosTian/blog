---
abbrlink: 0
---
# 1. 目标

> 在程序正确运行前提下，保证在大量数据集或者特殊情况下能够运行并得出正确结果

## 1.1 大量数据情况

由于简单选择排序，冒泡排序，插入排序的时间复杂度都是 $O(n^2)$ 。只要基于此思想，时间复杂度都不会低，如后例：

### 1.1.1 从 $N$ 个数中选择第 $k$ 大的数

#### 递减排序，取第K大的数

冒泡排序

```c
//对全部数据进行冒泡排序
void Bubble_Sort(int a[],int n){
	bool flag = false;
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= n-i;++j){
			if(a[j] < a[j+1]){
				swap(a[j],a[j+1]);
				flag = true;
			}
		}
	
	if(flag == false)
		return ;
	}
}

void Select_Sort(int a[],int n){
	for(int i = 1;i <= n;i++){
		int maxIdx = i;
		for(int j = i+1;j <= n;++j){
			if(a[j] > a[maxIdx])
				maxIdx = j;
		}
		if(maxIdx != i)
			swap(a[maxIdx],a[i]);
	}	
}

void KBig(int a[],int n,int k){

	//先排序
	Bubble_Sort(a,n);
	Select_Sort(a,n);

	return a[k];
}
```


#### 插入排序思想

取前 $K$个数递减排序。再取新数 $x_i$ ，从第一个数开始比较

- $x_i \ge a_i$ ：则将该数插入
- $x_i < a_k$ ：则不做操作

```c
//从小到大排序
void Direct_InsertSort(ElemType A[], int k){
	int i,j;
    for(i = 2;i <= k;++i){
        if(A[i] > A[i-1]){
            //若待插入元素A[i] > A[i-1] ，从后向前找插入位置
            A[0] = A[i];
            //A为一固定序列，且数据存储已定，所以需要哨兵记录待插入元素      
            for(j = i-1;j >= 0 && A[0] > A[j];--j)
                A[j+1] = A[j];
           	A[j+1] = A[0];
        }
    }
}

int KBig_Insert(int a[],int n,int k){
	///sort(a,k);//将前k个数据降序排序
	Direct_InsertSort(a,k);
	for(int i = k+1;i <= n;++i){
		if(a[i] > a[k]){
			a[0] = a[i];
			for(int j = k;j >= 0 && a[0] > a[j];--j)
				a[j+1] = a[j];
			a[j+1] = a[0];
		}
	}

	return a[k];//处理完全部数据后，第k个数据为所求
}

int main(){
	int n;//输入n省略
	int a = (int *)malloc(sizeof(int)*(n+1));
	for(int i = 1;i <= n;++i){
		//初始化n个数据
		...
	}
	KBig_Insert(a,n,k);

	return 0;
}
```


