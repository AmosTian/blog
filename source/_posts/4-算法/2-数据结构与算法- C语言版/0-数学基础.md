---
abbrlink: 1
---
# 1. 目标

> 在程序正确运行前提下，保证在大量数据集或者特殊情况下能够运行并得出正确结果

## 1.1 大量数据情况

由于简单选择排序，冒泡排序，插入排序的时间复杂度都是 $O(n^2)$ 。只要基于此思想，时间复杂度都不会低，如后例：

### 1.1.1 从 $N$ 个数中选择第 $k$ 大的数

#### 递减排序，取第K大的数

冒泡排序

```c
//对全部数据进行冒泡排序
void Bubble_Sort(int a[],int n){
	bool flag = false;
	for(int i = 1;i <= n;++i){
		for(int j = 1;j <= n-i;++j){
			if(a[j] < a[j+1]){
				swap(a[j],a[j+1]);
				flag = true;
			}
		}
	
	if(flag == false)
		return ;
	}
}

void Select_Sort(int a[],int n){
	for(int i = 1;i <= n;i++){
		int maxIdx = i;
		for(int j = i+1;j <= n;++j){
			if(a[j] > a[maxIdx])
				maxIdx = j;
		}
		if(maxIdx != i)
			swap(a[maxIdx],a[i]);
	}	
}

void KBig(int a[],int n,int k){

	//先排序
	Bubble_Sort(a,n);
	Select_Sort(a,n);

	return a[k];
}
```


#### 插入排序思想

取前 $K$个数递减排序。再取新数 $x_i$ ，从第一个数开始比较

- $x_i \ge a_i$ ：则将该数插入
- $x_i < a_k$ ：则不做操作

```c
//从小到大排序
void Direct_InsertSort(ElemType A[], int k){
	int i,j;
    for(i = 2;i <= k;++i){
        if(A[i] > A[i-1]){
            //若待插入元素A[i] > A[i-1] ，从后向前找插入位置
            A[0] = A[i];
            //A为一固定序列，且数据存储已定，所以需要哨兵记录待插入元素      
            for(j = i-1;j >= 0 && A[0] > A[j];--j)
                A[j+1] = A[j];
           	A[j+1] = A[0];
        }
    }
}

int KBig_Insert(int a[],int n,int k){
	///sort(a,k);//将前k个数据降序排序
	Direct_InsertSort(a,k);
	for(int i = k+1;i <= n;++i){
		if(a[i] > a[k]){
			a[0] = a[i];
			for(int j = k;j >= 0 && a[0] > a[j];--j)
				a[j+1] = a[j];
			a[j+1] = a[0];
		}
	}

	return a[k];//处理完全部数据后，第k个数据为所求
}

int main(){
	int n;//输入n省略
	int a = (int *)malloc(sizeof(int)*(n+1));
	for(int i = 1;i <= n;++i){
		//初始化n个数据
		...
	}
	KBig_Insert(a,n,k);

	return 0;
}
```

## 1.2 边界条件正确

# 2. 数学知识复习

## 2.1 指数

$$
X^AX^B=X^{A+B}
$$
$$
\frac{X^A}{X^B}=X^{A-B}
$$
$$
(X^{A})^B=X^{AB}
$$
$$
X^N+X^N=2X^N
$$

## 2.2 对数

在计算机中，除非特别声明，所有对数都是以2为底的

$$
log_AB=\frac{log_CB}{log_CA};C>0
$$
$$
logAB=logA+logB
$$
$$
log\frac{A}{B}=logA-logB
$$
$$
log(A^B)=BlogA
$$
$$
logX<X,X>0
$$
$$
log1=0,log2=1,log1024=10
$$
## 2.3 级数

### 2.3.1 几何级数

> 有是否收敛的区别

由等比数列求和 

$$
\sum_{i=0}^NA^i=\frac{1-A^{N+1}}{1-A}，0<A<1，当 N\rightarrow \infty 时，收敛于 \frac{1}{1-A}
$$
证明：

$$
\begin{aligned}
&S=1+A+A^2+\cdots\\
&AS=A+A^2+A^3+\cdots\\
&S-AS=1\Rightarrow S=\frac{1}{1-A}
\end{aligned}
$$
---
$$
\sum_{i=1}^\infty \frac{i}{2^i}=2
$$
证明：
$$
\begin{aligned}
&S=\frac{1}{2}+\frac{2}{2^2}+\frac{3}{2^3}+\cdots\\
&2S=1+\frac{2}{2}+\frac{2}{2^2}+\cdots\\
&2S-S=1+1\Rightarrow S=2
\end{aligned}
$$

### 2.3.2 算术级数

> 可以通过基本公式计算值

$$
\begin{aligned}
&\sum_{i=1}^N i=\frac{(1+N) N}{2}\approx\frac{N}{2}\\
&\sum_{i=1}^Ni^2=\frac{N(N+1)(2N+1)}{6}\approx\frac{N^3}{3}\\
&\vdots\\
&\sum_{i=1}^ni^k=\frac{N^{k+1}}{\vert k+1\vert},k\neq -1\\
&对于k=-1,调和数H_N=\sum_{i=1}^N\frac{1}{i}=log_eN
\end{aligned}
$$
SP：
$$
\begin{aligned}
&\sum_{i=1}^Nf(N)=N f(N)\\
&\sum_{i=n_0}^N f(i)= \sum_{i=1}^{N}f(i)-\sum_{i=n_1}^{n_0-1}f(i)
\end{aligned}
$$
## 2.4 模运算

A与B模N同余，记为 $$A\equiv B(mod\quad N)$$ 如： $$81\equiv 61\equiv 1(mod\quad 10)$$
### 性质
$$
\begin{aligned}
A\equiv B(mod N)&\Rightarrow (A+C)\equiv(B+C)(mod\quad N)\\
&\Rightarrow AD\equiv BD(mod\quad N)
\end{aligned}
$$
## 2.5 证明方法

### 2.5.1 归纳法

1. 证明基准情形
2. 归纳假设：假设定力对直到某个有限数k的所有情况都成立，在通过这个假设证明后续值成立。

#### 斐波那契

$$
\begin{cases}
&F_0=1,F_1=1\\
&F_i=F_{i-1}+F_{i-2},i\ge 2
\end{cases}
$$
证明：$$F_{k+1}< \left(\frac{5}{3}\right)^{k+1}$$ **证明：**
$$
\begin{aligned}
&当k=0时，F_1=1<\frac{5}{3}，则在k=0时成立\\
&假设k=m-1时，有F_{m}< \left(\frac{5}{3}\right)^{m}成立\\
&则当k=m时，F_{m+1}< \left(\frac{5}{3}\right)^{m}+\left(\frac{5}{3}\right)^{m-1}<\left(\frac{3}{5}\right)\left(\frac{5}{3}\right)^{m+1}+\left(\frac{3}{5}\right)^2\left(\frac{5}{3}\right)^{m+1}\\
&<\left(\frac{3}{5}+\frac{9}{25}\right)\left(\frac{5}{3}\right)^{m+1}=\frac{24}{25}\left(\frac{5}{3}\right)^{m+1}<\left(\frac{5}{3}\right)^{m+1}
\end{aligned}
$$
### 2.5.2 反证法

# 3. 递归简论

四条基本法则

- 基准情形：某些基准情形，无需递归就能解出
- 不断推进：每次递归调用，必须向基准情形推进（不能出现循环定义）
- 设计法则：假设所有递归调用都能运行
- 合成效益法则：不同递归调用做不同的工作

```c
void printOut(unsigned int N){
	if(N >= 10)
		printOut(N/10);
	// printDight(n)表示将单个数字输出到显示终端
	printDigit(N-(N/10)*10);//printDigit(N%10);	
}
```
- 取模运算耗费很大？

# 练习题







